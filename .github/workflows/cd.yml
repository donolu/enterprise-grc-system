name: CD - Build, Deploy (Slots), and Scan

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options: [staging, production]

# Required for GHCR, Code Scanning, and Azure OIDC
permissions:
  contents: read
  packages: write
  security-events: write
  id-token: write

# Prevent overlapping deploys per branch/env
concurrency:
  group: cd-${{ github.ref }}-${{ github.event.inputs.environment || 'push' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: grc-platform
  COMPOSE_PATH: deploy/docker-compose.webapp.yml
  HEALTH_PATH: /health/

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.pick.outputs.primary }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up QEMU
    # Needed for linux/arm64 cross-builds
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GHCR
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix=sha-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Pick primary image tag (prefer sha-)
      id: pick
      run: |
        tags="${{ steps.meta.outputs.tags }}"
        primary="$(printf "%s\n" "$tags" | grep '^ghcr\.io/.*/sha-' | head -n1)"
        [ -z "$primary" ] && primary="$(printf "%s\n" "$tags" | head -n1)"
        echo "primary=$primary" >> "$GITHUB_OUTPUT"
        echo "Chosen image tag: $primary"

    - name: Build and push (multi-arch)
      id: build
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.pick.outputs.primary }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_ENV=production

    - name: Generate SBOM (SPDX)
      uses: anchore/sbom-action@v0
      with:
        image: ${{ steps.pick.outputs.primary }}
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.spdx.json

  deploy-staging-slot:
    name: Deploy to Staging Slot (Blue/Green)
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: staging
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')

    steps:
    - uses: actions/checkout@v4

    - name: Azure Login (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Detect Compose vs Single image
      id: detect
      run: |
        if [ -f "${{ env.COMPOSE_PATH }}" ]; then
          echo "mode=compose" >> "$GITHUB_OUTPUT"
          echo "âœ… Found Docker Compose config at ${{ env.COMPOSE_PATH }}"
        else
          echo "mode=single" >> "$GITHUB_OUTPUT"
          echo "âš ï¸  No Docker Compose config found at ${{ env.COMPOSE_PATH }}, using single container mode"
        fi

    # If pulling private GHCR images WITHOUT Managed Identity:
    # (One-time app settings; safe to re-apply)
    - name: Configure registry creds (optional for GHCR)
      if: steps.detect.outputs.mode == 'single'
      env:
        GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
        GHCR_PAT: ${{ secrets.GHCR_PAT }}
      uses: azure/CLI@v1
      with:
        inlineScript: |
          if [[ -n "$GHCR_USERNAME" && -n "$GHCR_PAT" ]]; then
            az webapp config appsettings set \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_WEBAPP_NAME }} \
              --slot ${{ secrets.AZURE_SLOT_STAGING }} \
              --settings \
                DOCKER_REGISTRY_SERVER_URL=https://ghcr.io \
                DOCKER_REGISTRY_SERVER_USERNAME="$GHCR_USERNAME" \
                DOCKER_REGISTRY_SERVER_PASSWORD="$GHCR_PAT"
          else
            echo "GHCR credentials not provided, skipping registry configuration"
          fi

    # --- Single-container deploy to slot
    - name: Deploy single container to staging slot
      if: ${{ steps.detect.outputs.mode == 'single' }}
      uses: azure/webapps-deploy@v3
      with:
        app-name: ${{ secrets.AZURE_WEBAPP_NAME }}
        slot-name: ${{ secrets.AZURE_SLOT_STAGING }}
        images: ${{ needs.build-and-push.outputs.image-tag }}

    # --- Multi-container (Compose) deploy to slot
    - name: Deploy compose to staging slot
      if: ${{ steps.detect.outputs.mode == 'compose' }}
      uses: azure/CLI@v1
      with:
        inlineScript: |
          az webapp config container set \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_WEBAPP_NAME }} \
            --slot ${{ secrets.AZURE_SLOT_STAGING }} \
            --multicontainer-config-type compose \
            --multicontainer-config-file "${{ env.COMPOSE_PATH }}"

    - name: Warm-up + Health Check (staging slot)
      env:
        HEALTH_URL: https://${{ secrets.AZURE_WEBAPP_NAME }}-${{ secrets.AZURE_SLOT_STAGING }}.azurewebsites.net${{ env.HEALTH_PATH }}
      run: |
        echo "Warming up staging slot..."
        for i in {1..15}; do
          if curl -fsS "$HEALTH_URL"; then
            echo "âœ… Staging slot healthy"; exit 0
          fi
          echo "â³ [$i/15] retry in 10s..."; sleep 10
        done
        echo "âŒ Staging slot health check failed"; exit 1

    - name: Swap staging -> production
      uses: azure/CLI@v1
      with:
        inlineScript: |
          az webapp deployment slot swap \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_WEBAPP_NAME }} \
            --slot ${{ secrets.AZURE_SLOT_STAGING }} \
            --target-slot production

    - name: Post-swap Health Check (production)
      env:
        HEALTH_URL: https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net${{ env.HEALTH_PATH }}
      run: |
        echo "Checking production after swap..."
        for i in {1..20}; do
          if curl -fsS "$HEALTH_URL"; then
            echo "âœ… Production healthy after swap"; exit 0
          fi
          echo "â³ [$i/20] retry in 10s..."; sleep 10
        done
        echo "âŒ Production health check failed"; exit 1

  rollback-on-failure:
    name: Rollback (Swap back)
    runs-on: ubuntu-latest
    needs: [deploy-staging-slot]
    if: failure()
    environment: production

    steps:
    - name: Azure Login (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Swap back production -> staging
      uses: azure/CLI@v1
      with:
        inlineScript: |
          echo "ðŸ”„ Rolling back: swapping production back to staging..."
          az webapp deployment slot swap \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_WEBAPP_NAME }} \
            --slot production \
            --target-slot ${{ secrets.AZURE_SLOT_STAGING }}

  security-scan-image:
    name: Security Scan (Image)
    runs-on: ubuntu-latest
    needs: build-and-push
    if: needs.build-and-push.result == 'success'

    steps:
    - name: Trivy scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-push.outputs.image-tag }}
        format: sarif
        output: trivy-image-results.sarif

    - name: Upload SARIF to Code Scanning
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: trivy-image-results.sarif
